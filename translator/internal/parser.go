package internal

import (
	"bufio"
	"fmt"
	"io"
	"strings"
)

// Parser implements a parser for the Hack VM language.
type Parser struct {
	scanner *bufio.Scanner
	command *Command
	err     error
}

// NewParser creates a new parser given a reader for a Hack VM language file.
//
// Successive calls to Parser.Parse will step through the commands in the file, skipping blank lines
// and comments. Call Parser.Command to get the parsed command. Call Parser.Err after using the
// Parser to check for errors.
func NewParser(r io.Reader) *Parser {
	return &Parser{scanner: bufio.NewScanner(r)}
}

// Parse advances the Parser to the next command. It returns false on reaching the end of the file
// and on error.
func (p *Parser) Parse() bool {
	if p.err != nil {
		return false
	}
	for {
		if !p.scanner.Scan() {
			p.err = p.scanner.Err()
			return false
		}
		line := p.scanner.Text()
		p.command, p.err = parseCommand(line)
		if p.err != nil {
			return false
		}
		if p.command != nil {
			return true
		}
	}
}

// Err returns the error generated by a call to Parse, if any.
func (p *Parser) Err() error {
	return p.err
}

// Command returns the command generated by a call to Parse.
func (p *Parser) Command() Command {
	return *p.command
}

func parseCommand(line string) (*Command, error) {
	line, _, _ = strings.Cut(line, "//")
	line = strings.TrimSpace(line)
	if line == "" {
		return nil, nil
	}
	parts := strings.Split(line, " ")
	if len(parts) == 0 {
		return nil, nil
	}
	name := parts[0]
	t := commandType(name)
	if t == InvalidCommand {
		return nil, fmt.Errorf("invalid VM command: %q", line)
	}
	args := parts[1:]
	if t.arity() != len(args) {
		return nil, fmt.Errorf("invalid VM command (expected %d arguments): %q", t.arity(), line)
	}
	cmd := &Command{Type: t}
	switch t {
	case ArithmeticCommand:
		cmd.Arg1 = name
	case PushCommand:
		cmd.Arg1 = args[0]
		cmd.Arg2 = args[1]
	case PopCommand:
		cmd.Arg1 = args[0]
		cmd.Arg2 = args[1]
	case LabelCommand:
		cmd.Arg1 = args[0]
	case GotoCommand:
		cmd.Arg1 = args[0]
	case IfCommand:
		cmd.Arg1 = args[0]
	case FunctionCommand:
		cmd.Arg1 = args[0]
		cmd.Arg2 = args[1]
	case ReturnCommand:
	default:
		return nil, fmt.Errorf("invalid VM command: %q", line)
	}
	return cmd, nil
}
